CREATE TABLE TEST1(
    ID VARCHAR2(10) PRIMARY KEY,
    NAME VARCHAR2(30),
    ADDR VARCHAR2(50)
);

--레코드 등록
INSERT INTO TEST1 VALUES('JO','아영','서울');
INSERT INTO TEST1 VALUES('KIM','철수','제주');
INSERT INTO TEST1 VALUES('HONG','길동','전주');
INSERT INTO TEST1 VALUES('LEE','산들','부산');
INSERT INTO TEST1 VALUES('CHA','선우','광주');
INSERT INTO TEST1 VALUES('JUNG','진영','충주');

--TEST1을 참조하는 테이블 생성 (ID에 해당하는 사람이 갖고 있는 JOB, SAL의 정보 제공)
CREATE TABLE TEST2(
    CODE CHAR(3) PRIMARY KEY,
    ID VARCHAR2(10) REFERENCES TEST1(ID), --FK
    JOB VARCHAR2(30),
    SAL NUMBER(3)    
);

SELECT * FROM TEST1;
SELECT * FROM TEST2;

INSERT INTO TEST2 VALUES('A01', 'JO', '강사', 200);
INSERT INTO TEST2 VALUES('A02', 'KIM', '개발자', 300);
INSERT INTO TEST2 VALUES('A03', 'HONG', '탐정', 250);
INSERT INTO TEST2 VALUES('A04', 'LEE', '가수', 320);
INSERT INTO TEST2 VALUES('A05', NULL, '가수', 200);

DELETE FROM TEST2 WHERE ID IS NULL;

--ID, NAME, JOB, SAL 검색하고 싶다 
-- SQL 조인 방식 
---동등조인(EQUI JOIN)
-- 테이블 명에 별칭 부여
SELECT T1.ID, T1.NAME, T2.JOB, T2.SAL
FROM TEST1 T1, TEST2 T2
WHERE T1.ID = T2.ID; -- 별칭이 선언됐을때 반드시 별칭.컬럼명

--OUTER JOIN : 기본은 동등조인이면서 한쪽 테이블의 모든 레코드를 검색하고 싶을 때
--1. LEFT OUTER JOIN
SELECT T1.ID, T1.NAME, T2.JOB, T2.SAL
FROM TEST1 T1, TEST2 T2
WHERE T1.ID = T2.ID(+);

--2. RIGHT OUTER JOIN
SELECT T1.ID, T1.NAME, T2.JOB, T2.SAL
FROM TEST1 T1, TEST2 T2
WHERE T1.ID(+) = T2.ID;

--3. FULL OUTER JOIN :SQL 조인 방식에서는 지원 안함, ANSI 조인 방식으로 해결하자

SELECT T1.ID, T1.NAME, T2.JOB, T2.SAL
FROM TEST1 T1, TEST2 T2
WHERE T1.ID(+) = T2.ID(+); -- x

--ANSI 조인방식
SELECT *
FROM TEST1 INNER JOIN TEST2 --INNER 생략 가능
ON TEST1.ID = TEST2.ID;

SELECT TEST1.ID, NAME, JOB, SAL
FROM TEST1 INNER JOIN TEST2 --INNER 생략 가능
ON TEST1.ID = TEST2.ID;

--테이블 이름에 별칭
SELECT T1.ID, NAME, JOB, SAL
FROM TEST1 T1 JOIN TEST2 T2 --INNER 생략 가능
ON T1.ID = T2.ID;

--USING 절 사용하기 - 조인 조건의 대상이 되는 컬럼의 이름이 동일할 때는 ON 대신에 USING을 사용할 수 있다
SELECT ID, NAME, JOB, SAL
FROM TEST1 JOIN TEST2  --INNER 생략 가능
USING(ID);

--NATURAL JOIN --조인을 하는 테이블에서 같은 컬럼명, 
--같은 타입을 갖는 컬럼을 기준으로 모두 조인을 해준다. --USING 사용할 필요가 없다
SELECT * 
FROM TEST1 NATURAL JOIN TEST2;

--OUTER JOIN
--1) LEFT OUTER JOIN
SELECT ID, NAME, ADDR, JOB, SAL
FROM TEST1 LEFT JOIN TEST2
USING(ID);

--2) RIGHT OUTER JOIN
SELECT ID, NAME, ADDR, JOB, SAL
FROM TEST1 RIGHT JOIN TEST2
USING(ID);

--3) FULL OUTER JOIN
SELECT ID, NAME, ADDR, JOB, SAL
FROM TEST1 FULL JOIN TEST2
USING(ID);

-- 3개의 테이블 조인하기
CREATE TABLE TEST3(
    CODE CHAR(3) PRIMARY KEY REFERENCES TEST2(CODE), -- PK+FK
    MANAGER_NAME VARCHAR2(30),
    PHONE VARCHAR2(30)
);

DESC TEST3;

INSERT INTO TEST3 VALUES('A01', '유재석', '111-1111');
INSERT INTO TEST3 VALUES('A02', '강호동', '222-2222');
INSERT INTO TEST3 VALUES('A03', '신동엽', '333-3333');

SELECT * FROM TEST1;
SELECT * FROM TEST2;
SELECT * FROM TEST3;

-- ID, NAME, ADDR, JOB, SAL, MANAGER_NAME, PHONE 정보 검색
--SQL 조인 방식
SELECT TEST1.ID, NAME, ADDR, JOB, SAL, MANAGER_NAME, PHONE
FROM TEST1, TEST2, TEST3
WHERE TEST1.ID = TEST2.ID AND TEST2.CODE = TEST3.CODE;

--ANSI 조인방식
SELECT *
FROM TEST1 JOIN TEST2 USING(ID) 
JOIN TEST3 USING(CODE);

--조인에 조건 넣기 - SAL이 300이상인 레코드 조회하기

SELECT TEST1.ID, NAME, ADDR, JOB, SAL, MANAGER_NAME, PHONE
FROM TEST1, TEST2, TEST3
WHERE TEST1.ID = TEST2.ID AND TEST2.CODE = TEST3.CODE
AND SAL >=300;

SELECT *
FROM TEST1 JOIN TEST2 USING(ID) 
JOIN TEST3 USING(CODE) AND SAL >= 3000; --X

SELECT *
FROM TEST1 JOIN TEST2 USING(ID) 
JOIN TEST3 USING(CODE) WHERE SAL >= 3000;

SELECT T1.ID, NAME, JOB, SAL
FROM TEST1 T1 JOIN TEST2 T2 --INNER 생략 가능
ON T1.ID = T2.ID AND SAL >= 300;

--------------------------------------------------------------
-- EMP테이블에서 사원의 정보 + 급여 등급을 함께 검색하고 싶다.
SELECT DISTINCT EMPNO, ENAME, JOB, SAL, GRADE
FROM EMP JOIN SALGRADE
ON SAL BETWEEN LOSAL AND HISAL
ORDER BY SAL;

--SELF 조인 - 자기자신테이블을 2개로 만들어서 조인(재귀적 관계)
-- EX) SMITH 사원의 관리자는 FORD입니다. 출력
SELECT E1.EMPNO, E1.ENAME 사원, E1.EMPNO, E2.ENAME 관리자
FROM EMP E1 JOIN EMP E2 --(E1은 사원 테이블, E2은 관리자테이블) SELF JOIN은 별칭 필수
ON E1.MGR = E2.EMPNO;

SELECT  E1.ENAME || '사원의 관리자는 ' || E2.ENAME ||'입니다.'
FROM EMP E1 LEFT JOIN EMP E2 --(E1은 사원 테이블, E2은 관리자테이블) SELF JOIN은 별칭 필수
ON E1.MGR = E2.EMPNO;

SELECT * FROM EMP;
SELECT * FROM SALGRADE;
